{"ast":null,"code":"// utils/mockApiUtils.js\n\nconst BASE_URL = 'http://localhost:5000'; // Update this with your actual backend URL\n\n// Function to generate a unique video id\nexport const generateVideoId = () => {\n  const numbers = \"0123456789\";\n\n  // Generate a random 6 digit number\n  let videoId = \"\";\n  for (let i = 0; i < 6; i++) {\n    videoId += numbers.charAt(Math.floor(Math.random() * numbers.length));\n  }\n  return videoId;\n};\n\n// Mock function to simulate video upload and return a video_id\nexport const uploadVideo = async videoFile => {\n  // Simulate a delay\n  await new Promise(resolve => setTimeout(resolve, 1500));\n\n  // Create a FormData object to send the video file\n  const formData = new FormData();\n  formData.append('video', videoFile);\n\n  // Simulate sending a POST request to the backend's video upload endpoint\n  try {\n    const response = await fetch(`${BASE_URL}/upload_video`, {\n      method: 'POST',\n      body: formData\n    });\n    if (!response.ok) {\n      throw new Error('Video upload failed');\n    }\n    const data = await response.json();\n    if (data.success) {\n      return {\n        success: true,\n        videoId: data.video_id\n      }; // Update the key to \"video_id\"\n    } else {\n      throw new Error('Return of videoId failed');\n    }\n  } catch (error) {\n    console.error(error);\n    return {\n      success: false,\n      videoId: null\n    };\n  }\n};\n\n// Mock function to simulate fetching analysis results from the backend\nexport const getAnalysisResults = async videoId => {\n  // Simulate a delay\n  await new Promise(resolve => setTimeout(resolve, 1500));\n\n  // Mock analysis results\n  const mockResults = {\n    analysisType: \"OCR and Data Analysis\",\n    videoId: videoId\n    // ... other analysis data ...\n  };\n\n  return mockResults;\n};\nexport const getFirstFrameUrl = async videoId => {\n  // Simulate a delay\n  await new Promise(resolve => setTimeout(resolve, 1000));\n\n  // Return URL to fetch image from the backend\n  return `${BASE_URL}/images/${videoId}/frame.jpg`; // Assuming 'frame.jpg' is the filename of the first frame\n};\n\nexport const getThumbnailUrls = async videoId => {\n  // Simulate a delay\n  await new Promise(resolve => setTimeout(resolve, 1000));\n\n  // Return URL to fetch image from the backend\n  return `${BASE_URL}/fetch_thumbnails/${videoId}`;\n};\n\n// Mock function to simulate sending grid selection to the backend\nexport const sendGridSelection = async (videoId, selectedRegions) => {\n  // Simulate a delay\n  await new Promise(resolve => setTimeout(resolve, 1000));\n  let formattedRegions = formatSelectedRegions(selectedRegions);\n  try {\n    const response = await fetch(`${BASE_URL}/submit_selection`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        videoId,\n        formattedRegions\n      }) // Include videoId in the JSON payload\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to send grid selection');\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error sending grid selection:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n// Format the selected regions into a data structure that the backend expects\nexport const formatSelectedRegions = selectedRegions => {\n  // currently, they are like this:         # selected_regions: [{'index': 2668, 'type': 'Stack'}, {'index': 2733, 'type': 'Stack'}, {'index': 2366, 'type': 'HoleCards'}, {'index': 2549, 'type': 'HoleCards'}]\n  // the backend expects them like this:    # selected_regions: ['type': 'Stack', 'indices': [2668, 2733]], ['type': 'HoleCards', 'indices': [2366, 2549]]\n  const formattedRegions = [];\n\n  // Group the selected regions by type\n  const regionsByType = selectedRegions.reduce((acc, region) => {\n    if (!acc[region.type]) {\n      acc[region.type] = [];\n    }\n    acc[region.type].push(region.index);\n    return acc;\n  }, {});\n\n  // Convert the grouped regions into the format that the backend expects\n  for (const [type, squares] of Object.entries(regionsByType)) {\n    formattedRegions.push({\n      type,\n      squares\n    });\n  }\n  return formattedRegions;\n};\nexport const getSelectionData = async videoId => {\n  try {\n    const response = await fetch(`${BASE_URL}/get_selection/${videoId}`);\n    const data = await response.json();\n    console.log('Fetched selection data:', data);\n    return data;\n  } catch (error) {\n    console.error('Error fetching selection data:', error);\n    return null;\n  }\n};\nexport const getOcrResults = async videoId => {\n  try {\n    const response = await fetch(`${BASE_URL}/data/${videoId}`);\n    const data = await response.json();\n    console.log('Fetched OCR results:', data);\n    return data;\n  } catch (error) {\n    console.error('Error fetching OCR results:', error);\n    return null;\n  }\n};","map":{"version":3,"names":["BASE_URL","generateVideoId","numbers","videoId","i","charAt","Math","floor","random","length","uploadVideo","videoFile","Promise","resolve","setTimeout","formData","FormData","append","response","fetch","method","body","ok","Error","data","json","success","video_id","error","console","getAnalysisResults","mockResults","analysisType","getFirstFrameUrl","getThumbnailUrls","sendGridSelection","selectedRegions","formattedRegions","formatSelectedRegions","headers","JSON","stringify","message","regionsByType","reduce","acc","region","type","push","index","squares","Object","entries","getSelectionData","log","getOcrResults"],"sources":["/root/Projects/linecheck/frontend/src/utils/mockApiUtils.js"],"sourcesContent":["// utils/mockApiUtils.js\n\nconst BASE_URL = 'http://localhost:5000'; // Update this with your actual backend URL\n\n// Function to generate a unique video id\nexport const generateVideoId = () => {\n  const numbers = \"0123456789\";\n\n  // Generate a random 6 digit number\n  let videoId = \"\";\n  for (let i = 0; i < 6; i++) {\n    videoId += numbers.charAt(Math.floor(Math.random() * numbers.length));\n  }\n\n  return videoId;\n};\n\n// Mock function to simulate video upload and return a video_id\nexport const uploadVideo = async (videoFile) => {\n  // Simulate a delay\n  await new Promise((resolve) => setTimeout(resolve, 1500));\n\n  // Create a FormData object to send the video file\n  const formData = new FormData();\n  formData.append('video', videoFile);\n\n  // Simulate sending a POST request to the backend's video upload endpoint\n  try {\n    const response = await fetch(`${BASE_URL}/upload_video`, {\n      method: 'POST',\n      body: formData,\n    });\n\n    if (!response.ok) {\n      throw new Error('Video upload failed');\n    }\n\n    const data = await response.json();\n    \n    if (data.success) {\n      return { success: true, videoId: data.video_id }; // Update the key to \"video_id\"\n    } else {\n      throw new Error('Return of videoId failed');\n    }\n  } catch (error) {\n    console.error(error);\n    return { success: false, videoId: null };\n  }\n};\n\n// Mock function to simulate fetching analysis results from the backend\nexport const getAnalysisResults = async (videoId) => {\n  // Simulate a delay\n  await new Promise((resolve) => setTimeout(resolve, 1500));\n\n  // Mock analysis results\n  const mockResults = {\n    analysisType: \"OCR and Data Analysis\",\n    videoId: videoId,\n    // ... other analysis data ...\n  };\n\n  return mockResults;\n};\n\nexport const getFirstFrameUrl = async (videoId) => {\n  // Simulate a delay\n  await new Promise((resolve) => setTimeout(resolve, 1000));\n\n  // Return URL to fetch image from the backend\n  return `${BASE_URL}/images/${videoId}/frame.jpg`; // Assuming 'frame.jpg' is the filename of the first frame\n};\n\nexport const getThumbnailUrls = async (videoId) => {\n  // Simulate a delay\n  await new Promise((resolve) => setTimeout(resolve, 1000));\n\n  // Return URL to fetch image from the backend\n  return `${BASE_URL}/fetch_thumbnails/${videoId}`;\n};\n\n// Mock function to simulate sending grid selection to the backend\nexport const sendGridSelection = async (videoId, selectedRegions) => {\n  // Simulate a delay\n  await new Promise((resolve) => setTimeout(resolve, 1000));\n\n  let formattedRegions = formatSelectedRegions(selectedRegions);\n\n  try {\n    const response = await fetch(`${BASE_URL}/submit_selection`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ videoId, formattedRegions }), // Include videoId in the JSON payload\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to send grid selection');\n    }\n\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    console.error('Error sending grid selection:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n// Format the selected regions into a data structure that the backend expects\nexport const formatSelectedRegions = (selectedRegions) => {\n  // currently, they are like this:         # selected_regions: [{'index': 2668, 'type': 'Stack'}, {'index': 2733, 'type': 'Stack'}, {'index': 2366, 'type': 'HoleCards'}, {'index': 2549, 'type': 'HoleCards'}]\n  // the backend expects them like this:    # selected_regions: ['type': 'Stack', 'indices': [2668, 2733]], ['type': 'HoleCards', 'indices': [2366, 2549]]\n  const formattedRegions = [];\n\n  // Group the selected regions by type\n  const regionsByType = selectedRegions.reduce((acc, region) => {\n    if (!acc[region.type]) {\n      acc[region.type] = [];\n    }\n    acc[region.type].push(region.index);\n    return acc;\n  }, {});\n\n  // Convert the grouped regions into the format that the backend expects\n  for (const [type, squares] of Object.entries(regionsByType)) {\n    formattedRegions.push({ type, squares });\n  }\n\n  return formattedRegions;\n};\n\n\n\nexport const getSelectionData = async (videoId) => {\n  try {\n    const response = await fetch(`${BASE_URL}/get_selection/${videoId}`);\n    const data = await response.json();\n    console.log('Fetched selection data:', data);\n    return data;\n  } catch (error) {\n    console.error('Error fetching selection data:', error);\n    return null;\n  }\n};\n\nexport const getOcrResults = async (videoId) => {\n  try {\n    const response = await fetch(`${BASE_URL}/data/${videoId}`);\n    const data = await response.json();\n    console.log('Fetched OCR results:', data);\n    return data;\n  } catch (error) {\n    console.error('Error fetching OCR results:', error);\n    return null;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}